# 架构师面试

### **1 流量洪峰短时间访问量陡增**

* 服务器扛不住，服务器就容易出现这个性能瓶颈来不及响应

**解决方案**

1. 为了保障整个服务的不被流量洪峰所击垮，那我们在这个网关层呢就必须做一个流量的限制。此如说设置**命牌筒token bucket**的算法在规定的时间内, 允许一定量的这个流量的涌入， 剩余的这个请求需要依次排队。
	* 在用户手机端呢就是等待超时，稍后再试一些提示
	* 第二就是应用的崩溃

2. 抵挡不了那么大的流量并发，实际的并发量远远超过理论上的这个最高的并发量，而运维人员的扩容是需要时间响应或者呢没有上云服务的弹性扩容。 没有办法根据流量来动态的增加相应的机器来保障服务，就是抵挡不了流量洪峰，应用崩溃

3. 第三点就是数据库的性能瓶颈，数据库集群的读写分离。满足不了足够多的数据请求。要增加一些数据库的服务器。比如说增加缓存服务器，就是做一些提前的计算。
	* 用户只要一一有请求，服务器就能够立马响应。以空间换时间的这么一个做法
4. 第四点呢就是第三方数据接口的崩溃。健康码关联的很多的数据，关联服务的调用。如果第三方的这个数据接口扛不住这么大的这个并发请求就会导致调用的超时服务的不可用

### **2 必须要掌握的数据库优化技巧**

这三个数据库设计的要点必须掌握, 分别是**主从复制**,**读写分离**, **分库分表,** 就需要去考虑增加数据库服务器。

一般的这个业务系统, 都是读多写少。 一般都会采用一主多从的数据库架构，一个主库搭配多个从库，那主库负责写，从库负责读。在读写的时候，通过触发器来判定读还是写，这就是我们常说的读写分离

**读写分离**

就可以大大的提高了这个数据库的查询效率又可以降低单库读写带来的这个并发沖突. 多个数据库之间的数据同步怎么办? 主从同步的原理数据库灾难的恢复的原理是一致的. 都是通过日志, 将记录的所有的这个dml操作重新执行—遍. 比如说Mysql 那主库所有的增删改, 都会存储在这个binlog 中. 就可以把所有的这个数据库操作, 从库上面全部执行一遍, 这样就会轻松的解決数据同步的间题

**分库**

如何存储平台的这个大数据量,单个的这个关系数据库的容量是有限的无法存放全部的数据, 因此需要分而治之,  就是常说分库分表.  根据数据的种类不同,可以以建立多介数据库, 单个数据库呢仅存放一种类别的数据. 商品数据, 用户数据, 物流数据等等那么就可以分别创建这三个数据库，来存放这三类数据

**分表**

分表就是把原先的一张大表，按照水平拆分的方式产生多个数据表。可以按时间拆分，哈西拆分，可以取余的方式拆分等等。 

要根据实际的这个业务，来做一些取舍，这个分表后的一个关联查询的问题因为数据分散在多个表中。要提前按照策路找到数据所在的这个数据表，才能进行后续的这个数据库的操作


### **3 Redis 热key和大value**

redis 的热key和大value如果处理不好造成的线上问题。正常情况下，像redis集群中，数据都是比较均勻的，分布在每一个节点。请求也会均勻的分布到每一个分片上， 但是一些特殊的场景中。比如说外部的爬虫， 攻击啊热点商品等等啊。

那么这种短时间内，某些key访问量过大然后请求到同一台数据分片上，最终导致该分片不堪重负，成为瓶颈，最终将会导致缓存雪崩

**那么怎么监测热 key**

常规就是根据业务以往的数据做一个判定，比如说我们的促销活动，或者在调用redis的时候，**写一个方法来判定**如果见到到某 1 key 的 qps 如果达到了这介 1000 可能就是一个热 key

**那么怎么解决热key**

可以扩容，增加分片。副本多了，自然压力就分担了一些。防止单个机器打挂。 

**还有一种呢就是使用这个二级缓存， 把热点数据呢放到 jvm 的本地缓存中。 本地缓存呢我们可以使用这个caffeine, guava. 这样就直接读到了本地缓存了, 不需要再去请求 redis**. 就省去了一次这个远程的io调用, 同样也可以使用一些框架, jd-hotkey 会自动的去监测你的熱 key并且转为ivm本地缓存

### **4 redist的大value**

有时候会把一个很大的值塞到同一个Key中， 比如说 **string 类型就会塞
一介很大的宇符串文本**，那么对于一些这个集合类的ist，set动不动就会塞个几万条的数据。 

那么这些大valure， 在项目前期可能不容易发现，但是一旦并发量大了之后，就会暴露很多的问题从而成为服务器的杀手。

比如说数据倾斜，那么大的Value会导致集群, **不同的节点的数据分布不均匀.那么有的多有的少, 会造成数据倾斜的向题**. 大量读写比例非常高的请求，就会落到同一个节点上，那么这个范点的负载，就会严重的升高，容易打挂。

另外大value, 在查询的时候呢会占用 redis server的缓存, 就会导致redis 服务器的缓冲区不足 ,大量的请求就会出现超时的现象. 数据库层被击穿的连锁反应

**怎么解決： 拆**

把你的大value, 大list拆成多个key-value. 将操作压力，平摊到多个 redis 实例中，降低对单个节点的 IO影响. 可以使用哈西算法去拆, 使用这个取模的算法去拆， 核心的思想是将value打散。每次只get 你需要的数据，类似于数据库中的分库分表

### **5 Redis 缓存雪崩**

**什么是缓存雪崩**

大量的查询请求，在redis层找不到数据，就会渗透到数据库层，那么数据库短时问内压力山大。大量的请求会造成查询阻塞，把数据库拖死了。

**怎么引起的缓震雪崩**

大批量的热点数据的过期，那么热点数据一旦过期，自然在redis里面就查不到数据，就会回源数据库。那么大井发量的请求， 在瞬间就会压到数据库上

**另一个原因**

就是redis实例发生了故障，那么无法处理请求，他拖死了Redis的节点，那么也会导致大量的请求积压到数据库层， 

那么对于数据过期，可以使用差异化去定义缓存过期时间，**那不要把大量的key 在同一个时间内过期**。 比如说在初始化缓存的同时， 给这些数据过期时间增加一个比较小的一个随机数，可以避免了大量的数据同时过期。又能保证这些数据在相近的时间内失效

**同时呢我们也可以让这个服务降级**， 允许核心业务访问数据库，非核心业务直接返回事先定义好的信息。 那么针对 redis服务宕机，可以做这个请求限流对。

**控制每秒进入应用程序的这个请求数，避免过多的请求压到数据库可以做服务熔断**。

暂停业务的应用，对缓存服务的访问，先走ivm缓存，从而降低对数据库的压力当然这些都是权益之计还是要保证redis集群的高可用性，那么主节点一旦宕机，那么从节点就可以快速的切换到主节点那么继续对外提供服务

### **6 Redis缓存穿透**

什么是缓存穿透，简单来讲就是在查找这个 key 在缓存和数据库中都不存在。导致每次请求数据， 从缓存中都获取不到， 从而将这个请求打到数据库上，但数据库中也没有对应的数据。 就是每一次请求，都直接打在数据库上面缓存不起任何的作用。 那么一旦并发量上来之后， 数据库压力就大了

**缓存穿透是怎么引起的， 常见就是数据同步的问题**。 库里突然删除了某一个商品的信息，可能是误操作。那微服务的其他板块的数据同步的比较慢或者同步失败。 那么列表中还有这条数据，恰巧访问这条数据的人很多。

访问redis没有数据，访问数据库也没有数据，这个就发生了一次穿透，**那么还有一种可能就是恶意攻击**，找一个不存在的 id，比如说 id 小于0，这个肯定是不存在的。 那么redis 中又没有预热， 数据库中也没有，如果再加上这个并发请求，就变成了恶意攻击数据库。

如果没有做特殊处理，瞬间就会打满数据库的 Cpu，那么最终系统可能会崩掉。

**怎么解決缓存穿透**。

那如果一个查询返回的数据为空，不管是数据不存在还是系统故障，我们仍然把这个空值进行缓存， 但它的过期时间呢可以设置的很短，最长不要超过5分钟。

为什么不能设置过长， 一个是占有缓存，另一个如果有了新数据。会造成数据不一致的情況。

**第二个方法呢就是使用布隆过滤器，判断请求对应的键，是否在这个过滤器中，如果不在就直接返回**。**不去请求数据库也不去缓存空值，极少的空间来标识超大量的数据**

### **7 如何保障redis挂了之后: 数据不丟失？**

redis数据是全部存储在内存中的, 那么如果机器突然挂, 那么数据就会全部丢.数据不会因为redis挂了而丢失, 就是redis所谓的特久化机制. 

持久化的存储比如说像这个磁盘上的文本文档, 日志文件, 还有数据库文件等等.  都是属于这个数据的持久化,  redis的持久化在磁盘上找一个地方来存储。 

**一种呢叫`rdb`，rdb就是`redisdatabase`**, 就是常说的这个redis数据库,叉叫内存存快照。 可以定时的去备份缓存中的数据，隔一段时间就会执行一次备份。 

就跟定期备份数据库文件一样,那如果redis挂了,再次启动的时候. 就会从最新的rdb文件中加载数据,  

另一个是aof，全称是`append only file`. 是在一个文件里面去追加他的命令，是记录redis缓存中所有的修改。 

新增的删除的日志， 都会以命令的方式， 一条一条的存储在日志中， 所以一旦redis挂了，重启redis的时候， 就会根据日志中的命令很轻松的来恢复数据。 就跟mysql中的binlog非常像，只存储命令。 

不存储数据需要的时候，需要恢复数据的时候，直接命令就OK。那么有了aof机制， 也可以往其他的一些中间键，都会以命令的方式，一条一条的存储在日志中， 所以—旦redis挂了， 重后redis的时候，就会根据日志中的命令。 恢复数据， 需要恢复数据的时候， 那么有了aof机制， 做了一些数据同步， 比如说像搜索引擎ES。

